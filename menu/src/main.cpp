#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <TouchScreen.h>
#include <Talkie.h>
#include <avr8-stub.h>
#include "menu.h"

/*

	set menus return value to prev-menu's selection value
	once value is set (if confirmed), set is popped and ui returns to circuit/param select

	need to keep system informed of ui state

*/

const uint8_t spt_SAVE[]              PROGMEM ={0x0A,0x78,0x46,0xD4,0x02,0x16,0x90,0x40,0x4B,0x7C,0xF2,0x50,0xEF,0x26,0x3B,0x39,0x49,0xEC,0x11,0x22,0xD5,0xF4,0x24,0xB1,0xB8,0x8B,0x4D,0x93,0x95,0xA6,0xAC,0xA6,0xB6,0x4D,0x76,0x36,0xF2,0x5C,0x44,0xD5,0xB7,0xF1,0xAA,0x72,0x15,0x55,0x9F,0x25,0xA3,0xCE,0x59,0x58,0xB3,0x6E,0x8F,0x26,0x67,0x61,0x8D,0x7C,0xDC,0x9A,0x9C,0x85,0x34,0x73,0xF6,0x68,0x4A,0x77,0x22,0xB3,0xA7,0xA3,0x29,0x31,0x98,0xC2,0xD6,0x94,0x36,0x06,0x55,0x73,0x69,0x12,0x3A,0x1F,0xC5,0x8D,0xB5,0x8D,0xEA,0x8C,0x34,0x09,0x33,0x37,0x66,0xE8,0x31,0xDD,0x58,0x69,0x33,0x20,0x84,0x14,0x04,0xE8,0xE8,0x81,0x00,0xED,0x5C,0x1F,0x00,0x00};
const uint8_t spt_COMPLETE[]          PROGMEM ={0x06,0x08,0xB9,0x65,0xE4,0xB6,0x54,0xB8,0x78,0x92,0x5D,0xED,0xAA,0xD4,0x2E,0x70,0x0B,0x9B,0x9A,0xDC,0x86,0xD6,0x7B,0x6C,0xA5,0xD4,0xEA,0x3A,0xE1,0xDD,0x13,0xCA,0x8E,0xE9,0x8D,0x32,0x0F,0x35,0x27,0x00,0x06,0xF0,0xD6,0xDC,0x02,0x25,0xF1,0xB2,0x3C,0xD4,0x16,0xEF,0x64,0x65,0x4E,0x87,0x56,0xC4,0xAC,0x51,0x04,0x2B,0xDC,0x99,0x75,0x5A,0x15,0x0C,0x6B,0x6D,0x26,0xEC,0x8D,0xEB,0xAD,0xC1,0xEE,0x28,0x2B,0xB2,0xC7,0x33,0x00,0x30,0xA0,0xB1,0x34,0x0D,0x70,0x80,0x02,0xF0};
const uint8_t spt_LOAD[]              PROGMEM ={0x21,0x37,0xCA,0x63,0xC1,0xBC,0xB5,0xDE,0x1B,0x9A,0x46,0xF3,0xD6,0xDA,0xE4,0xA0,0x87,0x32,0xDF,0xAA,0xA2,0x95,0x3D,0xCA,0x7C,0xAB,0x32,0xC6,0x7F,0x20,0xF3,0x8D,0x42,0x85,0xDE,0x02,0xC9,0x36,0x0A,0x1D,0x7B,0x0A,0xD1,0x7F,0xAB,0x94,0xEF,0x29,0x42,0xFF,0xAD,0x52,0xA6,0xA7,0x08,0xBB,0xB6,0x46,0x9B,0xD8,0x44,0xCC,0x57,0x3A,0xAB,0x7D,0xDD,0xA0,0x4F,0xEA,0xAD,0x8C,0x63,0x87,0xDE,0x69,0x74,0xCA,0x26,0x12,0xFA,0xA4,0xC9,0x5A,0x9E,0x71,0xF1,0x1C,0x26,0x6F,0xA8,0x2A,0x31,0x15,0x9B,0xA8,0x8A,0x6C,0xCB,0x54,0x6A,0xA2,0xB2,0xCA,0x7C,0x14,0xB1,0x89,0xCA,0xC8,0x74,0x75,0x12,0xA6,0xEE,0xC2,0x45,0x25,0xA9,0xED,0x44,0x9B,0x83,0xB9,0x73,0xA6,0x42,0x7D,0xB6,0x6E,0x06,0xA4,0xE4,0x01,0x00,0x00};
const uint8_t spt_ERROR[]             PROGMEM ={0x2B,0xAF,0xC9,0x9C,0xDC,0x97,0x9E,0xBC,0xE5,0x34,0x72,0x5F,0x77,0xF2,0x58,0x4D,0x35,0xA3,0xEB,0xCD,0x5A,0x6A,0x07,0x7B,0x27,0xAD,0xEA,0x59,0xCF,0x5B,0xE5,0xB6,0x89,0x37,0x6E,0xED,0x55,0xAF,0x7B,0xD7,0xFB,0x3A,0xF4,0xA1,0x8D,0xB6,0xB9,0xE8,0xD3,0x56,0x37,0xB9,0xA9,0x1A,0x43,0x5B,0xCC,0xEC,0x16,0x66,0xAB,0xA5,0x72,0x8B,0xAB,0x66,0xC6,0xA3,0xE4,0x01,0x00,0x00};
const uint8_t spt_DATA[]              PROGMEM ={0xAC,0x85,0x6E,0x22,0x2A,0x24,0xB3,0x96,0xA8,0xCC,0x4C,0x77,0x30,0x9A,0x99,0xCA,0x99,0x3D,0xC9,0xC9,0x63,0x52,0x93,0xD8,0xB9,0xB7,0x5A,0x79,0x1E,0x2C,0xE6,0xD3,0x66,0xE7,0x3B,0x37,0x00,0x33,0x9A,0x0E,0x28,0x3E,0xB9,0xD5,0xD1,0x3B,0x1B,0xE6,0x8C,0xD1,0xB8,0x6C,0x29,0x31,0x49,0x66,0x3B,0x7A,0xE7,0xB3,0xDC,0xE3,0x6E,0x19,0x5D,0x0F,0xD3,0xE8,0x2A,0x71,0xF2,0xB3,0x19,0xA3,0xB3,0x30,0x28,0xCB,0xAC,0x0B,0xB7,0x58,0xC9,0x9D,0xC0,0x03,0x00,0x00};
const uint8_t spa_RESET[]     PROGMEM = {0xAA,0xF0,0x4D,0x54,0x22,0x5B,0xFB,0xAC,0xC5,0x49,0x53,0x66,0x5A,0xCB,0x15,0x76,0xCB,0xA8,0x1B,0xAD,0x56,0x70,0x8C,0x21,0xCF,0x34,0xDA,0xC1,0x76,0x9B,0xBB,0xAC,0x83,0xCC,0x34,0x72,0x7E,0x93,0x42,0x39,0x3D,0x4B,0x01,0x17,0xBB,0x69,0x40,0x00,0x8F,0x85,0x09,0xE0,0xCA,0x0C,0x01,0x5C,0x16,0x29,0x80,0x2B,0x23,0x0C,0xB0,0x69,0x7A,0x2B,0xAA,0x16,0x1B,0xA9,0xD8,0xAB,0x6F,0x56,0x75,0xDC,0x67,0xAF,0xA1,0x7B,0x93,0x4A,0x5B,0x3C,0xC6,0x91,0x42,0xD3,0x74,0x71,0x9A,0xAA,0x93,0x68,0xEB,0x29,0x6C,0x11,0xCA,0xDD,0x45,0x64,0x03,0x28,0x60,0x28,0x77,0x01,0x3C,0x23,0x29,0x80,0x6B,0xD4,0x09,0xB0,0x98,0x27,0x02,0x0A,0x2D,0xFB,0x39,0x25,0x55,0x15,0x51,0x25};
const uint8_t spt_OFF[]               PROGMEM ={0x2B,0xD5,0xF5,0xC2,0xD4,0xEB,0x9E,0xCA,0x99,0x6B,0x53,0x5D,0x7A,0x2A,0x53,0x66,0x94,0x33,0xCD,0xAD,0x6E,0x75,0xAB,0xDB,0xB4,0x4E,0xFB,0x1C,0x65,0x4B,0x68,0x80,0x6A,0x33,0x3C,0x60,0x01,0x0F,0x38,0x20,0xDB,0x0C,0x03,0xE4,0x98,0xF6};
const uint8_t spt_ON[]                PROGMEM ={0xA7,0x36,0x7E,0xC6,0xD9,0x97,0x9E,0xC2,0xA4,0x2D,0xA5,0x4E,0x7A,0xAB,0x5B,0xED,0x6A,0x57,0xBB,0x9E,0xCD,0x68,0x75,0x4F,0x37,0x2F,0xBB,0xBD,0x2B,0x9D,0x6E,0x91,0xE6,0xE5,0xD8,0xF4,0xD2,0x49,0xB1,0x8D,0x1B,0xDB,0x99,0x4E,0x3A,0x69,0xB1,0x71,0xAC,0x3A,0x1E,0xB4,0x42,0xC7,0x76,0xE8,0x02,0x77,0x35,0xD7,0xC6,0xAE,0x0B,0x29,0x0C,0x31,0x5D,0x22,0x40,0x57,0xE2,0x07,0x00,0x00};
const uint8_t sp2_FAIL[] PROGMEM = {0x04,0x98,0x3E,0x8D,0x03,0x1C,0xD0,0x80,0x07,0x4A,0xBF,0x54,0x9B,0x3A,0x79,0x9C,0xCD,0xAA,0x9B,0x0F,0x31,0x8F,0x37,0xB7,0xBE,0xCD,0x6A,0x47,0x2A,0x66,0xB3,0xB7,0xB3,0xDB,0x6B,0x5F,0xC7,0x56,0x44,0x58,0x8E,0x76,0xAA,0x7B,0xD8,0x33,0xB9,0x32,0xD7,0x3C,0xF9,0x0C,0x67,0xD4,0x13,0x9E,0x98,0xC7,0x5F,0xEE,0x49,0x7C,0xAA,0x8D,0xF3,0xF9,0xF7,0xFF,0x01};
const uint8_t sp3_CLEAR[] PROGMEM = {0x0C,0xC8,0xA3,0x39,0x00,0xC5,0x96,0x3B,0xA0,0x73,0x4F,0x03,0x4C,0xAD,0xD5,0xB2,0xCC,0x6C,0x42,0xB8,0xCB,0xCA,0x1A,0xE7,0xAC,0xE4,0xB6,0x2B,0x9F,0x46,0xC2,0x82,0xB6,0xAD,0x62,0x5A,0x37,0x0A,0xDE,0xB6,0x8A,0x19,0xDA,0xC1,0x69,0xDB,0x2A,0xA6,0x2B,0x85,0x90,0xAD,0xAB,0x9C,0xAE,0x04,0x53,0xB6,0xAC,0x72,0xD8,0x12,0x2C,0xD9,0x32,0xAA,0xE6,0x9A,0xB8,0x65,0xCB,0xA8,0xAA,0x6D,0xD4,0x95,0x2E,0xA5,0x2A,0xB6,0x51,0x4F,0xB2,0xA5,0xAA,0xA4,0x45,0x59,0xF1,0xFA,0xFF};

// #define SOUND_ENABLED

// This is calibration data for the raw touch data to the screen coordinates
#define TS_MINX 100
#define TS_MINY 100
#define TS_MAXX 900
#define TS_MAXY 900
#define PRESSURE_THRESH 40

#define XPOS    A2
#define YPOS    A3
#define YMIN    A1
#define XMIN    A0
volatile uint8_t *PORT_F = (uint8_t*)0x31;
volatile uint8_t *DDR_F = (uint8_t*)0x30;
#define CLIPP   4

#define TFT_CS 	37
#define TFT_DC 	36

#define M_SIZE (vec2){320,240}

#define NUM_PRESETS 6
#define SAVE 		0
#define LOAD 		1
#define DEL  		2

static int sound_en;
TouchScreen ts = TouchScreen(YPOS, XPOS, YMIN, XMIN, 300);
Adafruit_ILI9341 tft = Adafruit_ILI9341(tft8bitbus, 22, 35, 36, 37, 33, 34);
Talkie q;

menu_t *set_param;
menu_t *alert;
menu_t *popup;

menu_t *main_menu;
menu_t *timers;
menu_t *purge_timers;
menu_t *delay_timers;
menu_t *alarms;
menu_t *mode;
menu_t *presets;
menu_t *circuit_select;
menu_t *reclaimer_config;
menu_t *pick_param;
menu_t *pick_pid;
menu_t *pick_preset;

struct ui { 
	menu_t *active;
	menu_t *previous;

	int pidx;
	menu_t *path[8];
} ui;

static inline void click();
TSPoint get_press(TouchScreen *ts);
int preset_cb(menu_t *m, option_t *o);
int pick_preset_cb(menu_t *m, option_t *o);
int alarms_cb(menu_t *m, option_t *o);
void create_menus();
void init_options();
void init_menus();
int get_input();

void setup(void) {
  q.beginPWM(A4);
  tft.begin();
  tft.setRotation(1);
  tft.fillScreen(ILI9341_BLACK);
  init_menus();

  sound_en = 0;

  *DDR_F |= 1 << CLIPP;
  *PORT_F &= ~(1 << CLIPP);

  ui.active = main_menu;
  ui.previous = NULL;
  ui.path[0] = ui.active;
  ui.pidx = 0;

  m_draw(&tft, ui.active, 0);
}

void loop() {
  TSPoint p = get_press(&ts);
  if (p.z > PRESSURE_THRESH) {		// if pressure is above threshold
	int code = m_interact(ui.active, p);	// make interact-call with touch point
	if (code) click();
	switch (code) {
		case M_UPDATED:
			// triggers redraw/refresh
			m_draw(&tft, ui.active, M_CLEAR);
			m_draw(&tft, ui.active, M_DRAW);
			break;
		case M_SELECT:
			m_draw(&tft, ui.active, M_CLEAR);		// clear current menu
			ui.path[ui.pidx++] = ui.active;			// update path
			ui.active = ui.active->options[ui.active->cursor].target;	// swap active menu
			m_draw(&tft, ui.active, M_DRAW);		// draw new active menu
			break;
		case M_CONFIRM:
			// grab previous menu
			ui.previous = ui.path[ui.pidx - 1];
			// copy over the value from the active menu, to the value in the selected option of previous
			ui.previous->options[ui.previous->cursor].value = ui.active->options[ui.active->cursor].value;
			// CONFIRM falls through to M_BACK, swapping to previous menu
		case M_BACK:
			if (ui.pidx) {
				m_draw(&tft, ui.active, M_CLEAR);
				ui.active = ui.path[--ui.pidx];
				m_draw(&tft, ui.active, M_DRAW);
			}			
			break;
		case M_EXIT:
			m_draw(&tft, ui.active, M_CLEAR);
			ui.active = ui.path[0];
			ui.pidx = 0;
			m_draw(&tft, ui.active, M_DRAW);
			break;
		case M_NOP:
		default:
			break;
	}
	if (code) click();
  }
}

static inline void click() {
	*PORT_F ^= 1 << CLIPP;
}

TSPoint get_press(TouchScreen *ts) {
  TSPoint p = ts->getPoint();
  while (ts->isTouching()) {
	p = ts->getPoint();
	p.x = map(p.x, TS_MINX, TS_MAXX, 0, tft.width());
	p.y = 240 - map(p.y, TS_MINY, TS_MAXY, 0, tft.height());
  }

  return p;
}

int preset_cb(menu_t *m, option_t *o) {
	// int selected_preset = m->options[m->cursor].value;
	int op;
	if (m->cursor == 0) { // save
		// overwrite check
		strcpy(alert->title, "SAVE ");
		op = SAVE; 
	} else if (m->cursor == 1) { // load
		strcpy(alert->title, "LOAD "); 
		op = LOAD;
	} else if (m->cursor == 2) { // delete
		strcpy(alert->title, "DELETE "); 
		op = DEL;
	}

	menu_t *target = o->target;		// o->target is always pick_preset
	for (int i = 0; i < target->nopts; i += 1) {
		target->options[i].value = op;
	}

	return M_SELECT;
}

int pick_preset_cb(menu_t *m, option_t *o) {
	int code = M_NOP;
	TSPoint p;

	strcat(alert->title, o->name);
	
	click();
	m_draw(&tft, m, M_CLEAR);		// clear preset selection menu
	click();
	m_draw(&tft, alert, M_DRAW);	// display alert (confirm/cancel)
	while (code == M_NOP) {			// wait for selection
		p = get_press(&ts);
		if (p.z > 50) code = m_interact(alert, p);
	}
	click();
	m_draw(&tft, alert, M_CLEAR);	// clear alert
	click();

	if (code == M_CONFIRM) {
		switch (o->value) {
			case SAVE:		// save preset
				// compute checksum
				// test save success
				sprintf(popup->title, "%s success.", alert->title);
				m_draw(&tft, popup, M_DRAW);
				if (sound_en) { q.say(spt_SAVE); q.say(spt_COMPLETE); } 
				else _delay_ms(M_POPDELAY);
				m_draw(&tft, popup, M_CLEAR);
				break;
			case LOAD:		// load preset
				sprintf(popup->title, "%s failed!", alert->title);
				m_draw(&tft, popup, M_DRAW);
				if (sound_en) { q.say(spt_LOAD); q.say(sp2_FAIL); } 
				else _delay_ms(M_POPDELAY);
				m_draw(&tft, popup, M_CLEAR);
				break;
			case DEL:		// delete preset
				sprintf(popup->title, "%s is done.", alert->title);
				m_draw(&tft, popup, M_DRAW);
				if (sound_en) { q.say(spt_DATA); q.say(sp3_CLEAR); } 
				else _delay_ms(M_POPDELAY);
				m_draw(&tft, popup, M_CLEAR);
				break;
			default:
				break;
		}
		popup->title[0] = '\0';

		return M_CONFIRM;
	}

	return M_BACK;
}

int alarms_cb(menu_t *m, option_t *o) {
	if (m->cursor == 0) {		// selected SOUND option
		int code = M_NOP, dir;
		TSPoint p;
		
		click();
		if (o->value == 0) {  			// off, turn on
			strcpy(alert->title, "Set Sound ON?");
			dir = 1;
		} else if (o->value == 1) { 	// on, turn off
			strcpy(alert->title, "Set Sound OFF?");
			dir = -1;
		}
		
		m_draw(&tft, m, M_CLEAR);		// clear preset selection menu
		click();
		m_draw(&tft, alert, M_DRAW);	// display alert (confirm/cancel)
		while (code == M_NOP) {			// wait for selection
			p = get_press(&ts);
			if (p.z > 50) {
				code = m_interact(alert, p);
			}
		}
		m_draw(&tft, alert, M_CLEAR);	// clear alert

		if (code == M_CONFIRM) {
			o->value += dir;
			sound_en = o->value;
			sprintf(popup->title, "Sound is %s.", (o->value) ? "ON" : "OFF");
			m_draw(&tft, popup, M_DRAW);
			if (sound_en && o->value) { q.say(spt_ON); }
			else if (sound_en && !o->value) { q.say(spt_OFF); }
			else _delay_ms(M_POPDELAY);
			m_draw(&tft, popup, M_CLEAR);
			return M_CONFIRM;
		}
	}

	return M_SELECT;
}

void create_menus() {
	alert = new_menu("", 0, CENTER, M_SIZE, M_MESSAGE, 0);
	popup = new_menu("", 0, CENTER, M_SIZE, M_POPUP, M_NOTITLE);
	set_param = new_menu("SET PARAMETER", 1, CENTER, M_SIZE, M_SET, 0);

	main_menu = new_menu("MAIN", 6, CENTER, M_SIZE, M_DEFAULT, M_NOBACK | M_NOEXIT);
	reclaimer_config = new_menu("RECLAIMER CONFIG", 4, CENTER, M_SIZE, M_DEFAULT, 0);
	timers = new_menu("TIMERS", 2, CENTER, M_SIZE, M_DEFAULT, 0);
	pick_pid = new_menu("PICK PID", 3, CENTER, M_SIZE, M_DEFAULT, 0);
	circuit_select = new_menu("PICK CIRCUIT", 7, CENTER, M_SIZE, M_DEFAULT, 0);

	alarms = new_menu("ALARMS", 6, CENTER, M_SIZE, M_DEFAULT, 0);
	alarms->cb = alarms_cb;
	presets = new_menu("PRESETS", 3, CENTER, M_SIZE, M_DEFAULT, 0);
	presets->cb = preset_cb;
	pick_preset = new_menu("PICK PRESET", NUM_PRESETS, CENTER, M_SIZE, M_DEFAULT, 0);
	pick_preset->cb = pick_preset_cb;
}

void init_options() {
	option_t opts[8];

	// SET MENU
	opts[0] = (option_t) {"", 		NULL,    1234};
	m_set_options(set_param, set_param->nopts, opts);
	
	// MAIN MENU
	opts[0] = (option_t) {"Presets", 	presets,   			0};
	opts[1] = (option_t) {"Times", 		timers,    			0};
	opts[2] = (option_t) {"PID",  		pick_pid,  			0};
	opts[3] = (option_t) {"Pressures", 	circuit_select,		0};
	opts[4] = (option_t) {"Alarms", 	alarms,    			0};
	opts[5] = (option_t) {"Reclaimer", 	reclaimer_config,   0};
	m_set_options(main_menu, main_menu->nopts, opts);

	// PRESETS
	opts[0] = (option_t) {"Save",	pick_preset,	0};
	opts[1] = (option_t) {"Load",	pick_preset,	0};
	opts[2] = (option_t) {"Delete",	pick_preset,	0};
	m_set_options(presets, presets->nopts, opts);

	// PICK PRESETS
	for (int i = 0; i < NUM_PRESETS; i += 1) {
		opts[i] = (option_t) { "", presets, 0 };
		sprintf(opts[i].name, "Preset %d", i);
	}
	m_set_options(pick_preset, pick_preset->nopts, opts);

	// CIRCUIT SELECT
	opts[0] = (option_t) {"MARX", 		set_param, 0};
	opts[1] = (option_t) {"MARXTG70", 	set_param, 0};
	opts[2] = (option_t) {"MTG",  		set_param, 0};
	opts[3] = (option_t) {"SWITCH", 	set_param, 0};
	opts[4] = (option_t) {"SWTG70",     set_param, 0};
	opts[5] = (option_t) {"Reclaim",   set_param, 0};
	opts[6] = (option_t) {"Min SUPLY", set_param, 0};
	m_set_options(circuit_select, circuit_select->nopts, opts);

	// RECLAIMER CONFIG
	opts[0] = (option_t) {"REC ON", 		set_param,  0};	// displays popup
	opts[1] = (option_t) {"REC OFF", 		set_param,  0};	// displays popup
	opts[2] = (option_t) {"MIN SPLY", 		set_param,  0};	
	opts[3] = (option_t) {"REC Delay",   	set_param,  0};
	m_set_options(reclaimer_config, reclaimer_config->nopts, opts);

	// ALARMS
	opts[0] = (option_t) {"Sound",		 	alarms,    	0}; // toggle menu or popup
	opts[1] = (option_t) {"MARX", 			set_param,  0};
	opts[2] = (option_t) {"MARXTG70", 		set_param, 	0};
	opts[3] = (option_t) {"MTG",  			set_param,  0};
	opts[4] = (option_t) {"SWITCH", 		set_param,  0};
	opts[5] = (option_t) {"SWTG70", 		set_param,  0};
	m_set_options(alarms, alarms->nopts, opts);

	// TIMERS
	opts[0] = (option_t) {"Purge", circuit_select,   0};
	opts[1] = (option_t) {"Delay", circuit_select,   0};
	m_set_options(timers, timers->nopts, opts);

	// PICK PID
	opts[0] = (option_t) {"KP",  circuit_select,    0};
	opts[1] = (option_t) {"KI",	 circuit_select,    0};
	opts[2] = (option_t) {"KD",  circuit_select,    0};
	m_set_options(pick_pid, pick_pid->nopts, opts);
}

void init_menus() {
	create_menus();
	init_options();
}


